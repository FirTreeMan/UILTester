{
  "Body": "Pilar has been studying multi-dimensioned arrays and writing programs to work with them. In addition, she recently found out\n\nthat not all languages use zero-base arrays which makes them more difficult to work with for a Java programmer. With zero-\nbased arrays, the first column of a 1-D array is element [0], the first row of a 2-D array is row [0], and the first layer of a 3-D\n\narray is layer [0]. Some other programming languages treat arrays differently than Java. In Java, a 3-D array of floats with 2\nlayers, each layer with 3 rows, and each row with 4 columns would be declared as follows:\n<img/>\nSuppose another language allows the programmer to specify a range for the index values instead of the size of that dimension.\nPerhaps, something like the following:\n<img/>\nThe arrays are actually the same size but the index values in the program code would have the stated ranges instead of 0..1, 0..2,\nand 0..3, respectively.\n\nIn addition, some programming languages allow for indexing of “slices” of an array. Using the above example, data[-2:-\n1][6:7][4:6] would be a “slice” consisting of the portion of layers [-2] and [-1] containing only rows [6] and [7]\ncontaining only columns [4], [5], and [6]. The “slice” would be 12 cells, those that are shaded in the following illustration\nwith the “back” layer pushed to the right.\n\n<img/>\n\n“Slices” of a 3-D array could result in either a 2-D or a 1-D portion of the array like the following examples:\n\n<img/>\n\nYour challenge is to implement such an array and addressing mechanism via Java program code.",
  "Input": "First line contains a single integer, number of test cases T, which will not exceed 20. For each test case, the next line\ncontains three comma-separated index ranges for a 3-D array, in the form LB<sub>1</sub>:UB<sub>1</sub>,LB<sub>2</sub>:UB<sub>2</sub>,LB<sub>3</sub>:UB<sub>3</sub> where LB<sub>1</sub>, LB<sub>2</sub>, and LB<sub>3</sub>\nare lower bounds and UB<sub>1</sub>, UB<sub>2</sub>, and UB<sub>3</sub> are upper bounds for the layers, rows, and columns, respectively. The bounds will not\nexceed the range -5000:5000 but there will be no more than 1000 data elements in the array. The following lines will contain\none comma-separated row of float data to populate the first layer’s first row and then each subsequent line fills the next row,\nfollowed by rows of data for subsequent layers. The data is followed by a single line with a single integer N, the number of\n“slices” to be processed, which will not exceed 20. That line is followed by N lines, each containing a single comma-separated\n“slice” in the form L<sub>1</sub>:L<sub>2</sub>,R<sub>1</sub>:R<sub>2</sub>,C<sub>1</sub>:C<sub>2</sub> where L’s are layer indexes, R’s are row indexes, and C’s are column indexes. All index\nvalues will be valid for the defined array with the first value ≤ the second value.",
  "Output": "For each test case, output a single line containing the number of elements in the “slice” or “chunk” and the sum of the\ndata items in that “slice” of the array with two decimal places, separated by a single colon “:” and no additional spacing.\nDisplay a line containing 20 equal signs “====================” after each test case."
}