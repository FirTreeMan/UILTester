{
  "Body": "Casandra’s friend, Leah, recently discovered a way to efficiently determine the <i>i</i><sup>th</sup> Gray Code number. Leah observed that, for\nan arbitrary bit width <i>w</i>, that the Gray Code ordering for those 2<sup>w</sup> numbers overlapped with the first 2<sup>w</sup> numbers of the Gray\nCode ordering for width <i>w</i> + 1. The following is a visualization of this process starting from <i>w</i> = 0, to <i>w</i> = 3:\n\n<img/>\n\nWhile this provides a nice visual understanding of this process, Casandra realized that the calculations shown above provides a\ndecently slow process, as, to generate the <i>i</i><sup>th</sup> Gray Code, you must first generate the 0th through <i>i</i> − 1<sup>th</sup> Gray Codes. As a result,\nCasandra decided to investigate into methods of generating an arbitrary Gray Code number without the need to compute prior\nGray Code numbers. In her research, Casandra found a process that allows her to further simplify this process using an XOR\noperation as follows, where g<sub>i</sub> is the <i>i</i><sup>th</sup> Gray Code:\n\ng<sub>i</sub> = <i>i</i> ⨁ (<i>i</i> ≫ 1)\n\nHaving now discovered an efficient and independent way of generating Gray Code numbers, Casandra began to investigate some\nof the many applications of Gray Code numbers, one of which she found particularly useful: Karnaugh Maps. Karnaugh Maps\ncan be used to efficiently and completely simplify Boolean expressions. For a given Boolean expression with <i>V</i> unique\nvariables, first you must create a truth table for that Boolean expression, where you iterate over all 2<sup>v</sup> permutations of true and\nfalse values. Suppose we had the Boolean expression:\n\n<i>Y</i> = <i>A</i> | (<i>B</i> & !<i>C</i>) | (<i>C</i> & !<i>B</i>)\n\nThen, the truth table for this expression would look like the following:\n\n<img/>\n\nNext, a Karnaugh Map can be generated by simply re-arranging the values from the table above:\n\n<img/>\n\nThe process of re-arranging this table is as follows: First, given the number of unique variables, <i>V</i>, create a table of\nsize <i>U</i> × <i>D</i>, where <i>U</i> = ⌈<i>V</i>/2⌉ (<i>V</i>/2 Rounded Up) and <i>D</i> = ⌊<i>V</i>/2⌋ (<i>V</i>/2 Rounded Down). From there, the first <i>U</i> variables will be\nrepresented by the column headers, and the remaining <i>D</i> variables will be represented by the row headers (note that the variables\nin the truth table are sorted alphabetically, and thus, the order in the Karnaugh Map maintains that sorting). Next, generate the\nGray Codes <i>g</i><sub>0</sub> through <i>g</i><sub><i>U</i>-1</sub>, and generate the Gray Codes <i>g</i><sub>0</sub> through <i>g</i><sub><i>D</i>-1</sub>. Take the Gray Codes <i>g</i><sub>0</sub> through <i>g</i><sub><i>U</i>-1</sub> and replace\nthe column headers. Similarly, take the Gray Codes <i>g</i><sub>0</sub> through <i>g</i><sub><i>D</i>-1</sub> and replace the row headers. Lastly, fill in the table for\nvalues of <i>Y</i> corresponding to the values of the <i>V</i> unique variables from the original truth table. See below for how the Karnaugh\nMap above was derived.\n\n<img/>\n\nBefore learning how to use Karnaugh Maps to simplify Boolean expressions, Casandra wants to ensure that she understands the\nprocess of generating them perfectly. As a result, she decides to test her understanding by writing a program that, given a\nBoolean expression, generates an equivalent Karnaugh Map for that Boolean expression.",
  "Input": "The first line of input will consist of a single integer <i>n</i> (1 ≤ <i>n</i> ≤ 50) denoting the number of testcases to follow. The\nnext <i>n</i> lines will each contain a single string denoting the Boolean expression that needs to be converted. Each of the <i>n</i> lines\nwill consist solely of the characters [‘A’-‘Z’] (uppercase ‘A’ through uppercase ‘Z’), ‘!’ (the logical NOT operator), ‘|’ (the\nlogical OR operator), ‘&’ (the logical AND operator), ‘^’ (the logical XOR operator), ‘(’ (the open parenthesis), and ‘)’ (the\nclose parenthesis). It is guaranteed that no two variables are directly adjacent to one another in the string, and are separated by,\nat least, 1 non-variable character. Additionally, it is guaranteed that if character <i>c</i> appears in the list of unique variables, then all\ncharacters starting from ‘A’ leading up until <i>c</i> also appear. Lastly, 2 ≤ <i>V</i> ≤ 10, as to prevent issues where the Karnaugh Map\nmatrix is only a vector, or grows too large.",
  "Output": "For each of Casandra’s <i>n</i> requests, print out the <i>U</i> × <i>D</i> Karnaugh Map matrix of the <i>Y</i>-values, where each row is\nseparated by a newline character, each column is separated with a single space, and each Karnaugh Map is followed by a\nnewline containing the string “--------” (a string of eight hyphens)."
}